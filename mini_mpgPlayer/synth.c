#include "synth.h"

#if 0
static const float dewin[32][16] =
{
	{
		0.0, -14.5, 106.5, -229.5, 1018.5, -2576.5, 3287.0, -18744.5,
		37519.0, 18744.5, 3287.0, 2576.5, 1018.5, 229.5, 106.5, 14.5
	}, {
		-0.5, -15.5, 109.0, -259.5, 1000.0, -2758.5, 2979.5, -19668.0,
		37496.0, 17820.0, 3567.0, 2394.0, 1031.5, 200.5, 104.0, 13.0
	}, {
		-0.5, -17.5, 111.0, -290.5, 976.0, -2939.5, 2644.0, -20588.0,
		37428.0, 16895.5, 3820.0, 2212.5, 1040.0, 173.5, 101.0, 12.0
	}, {
		-0.5, -19.0, 112.5, -322.5, 946.5, -3118.5, 2280.5, -21503.0,
		373.5, 15973.5, 4046.0, 2031.5, 1043.5, 147.0, 98.0, 10.5
	}, {
		-0.5, -20.5, 113.5, -355.5, 911.0, -3294.5, 1888.0, -22410.5,
		37156.5, 15056.0, 4246.0, 1852.5, 1042.5, 122.0, .5, 9.5
	}, {
		-0.5, -22.5, 114.0, -389.5, 869.5, -3467.5, 1467.5, -23308.5,
		36954.0, 14144.5, 4420.0, 1675.5, 1037.5, 98.5, 91.5, 8.5
	}, {
		-0.5, -24.5, 114.0, -424.0, 822.0, -3635.5, 1018.5, -241.5,
		36707.5, 13241.0, 4569.5, 1502.0, 1028.5, 76.5, 88.0, 8.0
	}, {
		-1.0, -26.5, 113.5, -459.5, 767.5, -3798.5, 541.0, -25068.5,
		36417.5, 12347.0, 4694.5, 1331.5, 1016.0, 55.5, 84.5, 7.0
	}, {
		-1.0, -29.0, 112.0, -495.5, 707.0, -39.5, .5, -25926.5,
		36084.5, 11464.5, 4796.0, 11.5, 1000.5, 36.0, 80.5, 6.5
	}, {
		-1.0, -31.5, 110.5, -532.0, 640.0, -4104.5, -499.0, -26767.0,
		35710.0, 10594.5, 48.5, 1003.0, 981.0, 18.0, 77.0, 5.5
	}, {
		-1.0, -34.0, 107.5, -568.5, 565.5, -4245.5, -1061.0, -27589.0,
		352.5, 9739.0, 4931.5, 846.0, 959.5, 1.0, 73.5, .5
	}, {
		-1.5, -36.5, 104.0, -6.5, 4.5, -4377.5, -1650.0, -28389.0,
		34839.5, 8899.5, 4967.5, 694.0, 9.5, -14.5, 69.5, 4.5
	}, {
		-1.5, -39.5, 100.0, -641.5, 397.0, -4499.0, -2266.5, -29166.5,
		34346.0, 8077.5, 4983.0, 547.5, 908.5, -28.5, 66.0, 4.0
	}, {
		-2.0, -42.5, 94.5, -678.0, 302.5, -4609.5, -2909.0, -29919.0,
		33814.5, 7274.0, 4979.5, 407.0, 879.5, -41.5, 62.5, 3.5
	}, {
		-2.0, -45.5, 88.5, -714.0, 201.0, -4708.0, -3577.0, -30644.5,
		33247.0, 6490.0, 4958.0, 272.5, 849.0, -53.0, 58.5, 3.5
	}, {
		-2.5, -48.5, 81.5, -749.0, 92.5, -4792.5, -4270.0, -31342.0,
		326.5, 5727.5, 4919.0, 144.0, 817.0, -63.5, 55.5, 3.0
	}, {
		-2.5, -52.0, 73.0, -783.5, -22.5, -4863.5, -4987.5, -32009.5,
		32009.5, 4987.5, 4863.5, 22.5, 783.5, -73.0, 52.0, 2.5
	}, {
		-3.0, -55.5, 63.5, -817.0, -144.0, -4919.0, -5727.5, -326.5,
		31342.0, 4270.0, 4792.5, -92.5, 749.0, -81.5, 48.5, 2.5
	}, {
		-3.5, -58.5, 53.0, -849.0, -272.5, -4958.0, -6490.0, -33247.0,
		30644.5, 3577.0, 4708.0, -201.0, 714.0, -88.5, 45.5, 2.0
	}, {
		-3.5, -62.5, 41.5, -879.5, -407.0, -4979.5, -7274.0, -33814.5,
		29919.0, 2909.0, 4609.5, -302.5, 678.0, -94.5, 42.5, 2.0
	}, {
		-4.0, -66.0, 28.5, -908.5, -547.5, -4983.0, -8077.5, -34346.0,
		29166.5, 2266.5, 4499.0, -397.0, 641.5, -100.0, 39.5, 1.5
	}, {
		-4.5, -69.5, 14.5, -9.5, -694.0, -4967.5, -8899.5, -34839.5,
		28389.0, 1650.0, 4377.5, -4.5, 6.5, -104.0, 36.5, 1.5
	}, {
		.5, -73.5, -1.0, -959.5, -846.0, -4931.5, -9739.0, -352.5,
		27589.0, 1061.0, 4245.5, -565.5, 568.5, -107.5, 34.0, 1.0
	}, {
		-5.5, -77.0, -18.0, -981.0, -1003.0, -48.5, -10594.5, -35710.0,
		26767.0, 499.0, 4104.5, -640.0, 532.0, -110.5, 31.5, 1.0
	}, {
		-6.5, -80.5, -36.0, -1000.5, -11.5, -4796.0, -11464.5, -36084.5,
		25926.5, -.5, 39.5, -707.0, 495.5, -112.0, 29.0, 1.0
	}, {
		-7.0, -84.5, -55.5, -1016.0, -1331.5, -4694.5, -12347.0, -36417.5,
		25068.5, -541.0, 3798.5, -767.5, 459.5, -113.5, 26.5, 1.0
	}, {
		-8.0, -88.0, -76.5, -1028.5, -1502.0, -4569.5, -13241.0, -36707.5,
		241.5, -1018.5, 3635.5, -822.0, 424.0, -114.0, 24.5, 0.5
	}, {
		-8.5, -91.5, -98.5, -1037.5, -1675.5, -4420.0, -14144.5, -36954.0,
		23308.5, -1467.5, 3467.5, -869.5, 389.5, -114.0, 22.5, 0.5
	}, {
		-9.5, -.5, -122.0, -1042.5, -1852.5, -4246.0, -15056.0, -37156.5,
		22410.5, -1888.0, 3294.5, -911.0, 355.5, -113.5, 20.5, 0.5
	}, {
		-10.5, -98.0, -147.0, -1043.5, -2031.5, -4046.0, -15973.5, -373.5,
		21503.0, -2280.5, 3118.5, -946.5, 322.5, -112.5, 19.0, 0.5
	}, {
		-12.0, -101.0, -173.5, -1040.0, -2212.5, -3820.0, -16895.5, -37428.0,
		20588.0, -2644.0, 2939.5, -976.0, 290.5, -111.0, 17.5, 0.5
	}, {
		-13.0, -104.0, -200.5, -1031.5, -2394.0, -3567.0, -17820.0, -37496.0,
		19668.0, -2979.5, 2758.5, -1000.0, 259.5, -109.0, 15.5, 0.5
	}
};

static void dct32to64(const float* src, float* dest, int off)
{
	const float* in = src;
	float* out = dest;
	int i = off;
	float in0, in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15;
	float out0, out1, out2, out3, out4, out5, out6, out7, out8, out9, out10, out11, out12, out13, out14, out15;
	float d8_0, d8_1, d8_2, d8_3, d8_4, d8_5, d8_6, d8_7;
	float ein0, ein1, oin0, oin1;

	//>>>>>>>>>>>>>>>>
	// 用DCT16计算DCT32输出[0..31]的偶数下标元素
	in0 = in[0] + in[31];
	in1 = in[1] + in[30];
	in2 = in[2] + in[29];
	in3 = in[3] + in[28];
	in4 = in[4] + in[27];
	in5 = in[5] + in[26];
	in6 = in[6] + in[25];
	in7 = in[7] + in[24];
	in8 = in[8] + in[23];
	in9 = in[9] + in[22];
	in10 = in[10] + in[21];
	in11 = in[11] + in[20];
	in12 = in[12] + in[19];
	in13 = in[13] + in[18];
	in14 = in[14] + in[17];
	in15 = in[15] + in[16];

	//DCT16
	//{
		//>>>>>>>> 用DCT8计算DCT16输出[0..15]的偶数下标元素
	d8_0 = in0 + in15;
	d8_1 = in1 + in14;
	d8_2 = in2 + in13;
	d8_3 = in3 + in12;
	d8_4 = in4 + in11;
	d8_5 = in5 + in10;
	d8_6 = in6 + in9;
	d8_7 = in7 + in8;

	//DCT8. 加(减)法29,乘法12次
	//{
		//>>>>e 用DCT4计算DCT8的输出[0..7]的偶数下标元素
	out1 = d8_0 + d8_7;
	out3 = d8_1 + d8_6;
	out5 = d8_2 + d8_5;
	out7 = d8_3 + d8_4;

	//>>e DCT2
	ein0 = out1 + out7;
	ein1 = out3 + out5;
	out[i + 48] = -ein0 - ein1;
	out[i] = (ein0 - ein1) * 0.7071068f;// 0.5/cos(PI/4)

	//>>o DCT2
	oin0 = (out1 - out7) * 0.5411961f;	// 0.5/cos( PI/8)
	oin1 = (out3 - out5) * 1.3065630f;	// 0.5/cos(3PI/8)

	out2 = oin0 + oin1;
	out12 = (oin0 - oin1) * 0.7071068f; // cos(PI/4)

	out[i + 40] = out[i + 56] = -out2 - out12;
	out[i + 8] = out12;
	//<<<<e 完成计算DCT8的输出[0..7]的偶数下标元素

	//>>>>o 用DCT4计算DCT8的输出[0..7]的奇数下标元素
	//o DCT4 part1
	out1 = (d8_0 - d8_7) * 0.5097956f;	// 0.5/cos( PI/16)
	out3 = (d8_1 - d8_6) * 0.6013449f;	// 0.5/cos(3PI/16)
	out5 = (d8_2 - d8_5) * 0.8999762f;	// 0.5/cos(5PI/16)
	out7 = (d8_3 - d8_4) * 2.5629154f;	// 0.5/cos(7PI/16)

	//o DCT4 part2

	//e DCT2 part1
	ein0 = out1 + out7;
	ein1 = out3 + out5;

	//o DCT2 part1
	oin0 = (out1 - out7) * 0.5411961f;	// 0.5/cos(PI/8)
	oin1 = (out3 - out5) * 1.3065630f;	// 0.5/cos(3PI/8)

	//e DCT2 part2
	out1 = ein0 + ein1;
	out5 = (ein0 - ein1) * 0.7071068f;	// cos(PI/4)

	//o DCT2 part2
	out3 = oin0 + oin1;
	out7 = (oin0 - oin1) * 0.7071068f;	// cos(PI/4)
	out3 += out7;

	//o DCT4 part3
	out[i + 44] = out[i + 52] = -out1 - out3;	//out1+=out3
	out[i + 36] = out[i + 60] = -out3 - out5;	//out3+=out5
	out[i + 4] = out5 + out7;					//out5+=out7
	out[i + 12] = out7;
	//<<<<o 完成计算DCT8的输出[0..7]的奇数下标元素
//}
//<<<<<<<< 完成计算DCT16输出[0..15]的偶数下标元素

//-----------------------------------------------------------------

//>>>>>>>> 用DCT8计算DCT16输出[0..15]的奇数下标元素
	d8_0 = (in0 - in15) * 0.5024193f;	// 0.5/cos( 1 * PI/32)
	d8_1 = (in1 - in14) * 0.5224986f;	// 0.5/cos( 3 * PI/32)
	d8_2 = (in2 - in13) * 0.5669440f;	// 0.5/cos( 5 * PI/32)
	d8_3 = (in3 - in12) * 0.6468218f;	// 0.5/cos( 7 * PI/32)
	d8_4 = (in4 - in11) * 0.7881546f;	// 0.5/cos( 9 * PI/32)
	d8_5 = (in5 - in10) * 1.0606777f;	// 0.5/cos(11 * PI/32)
	d8_6 = (in6 - in9) * 1.7224471f;	// 0.5/cos(13 * PI/32)
	d8_7 = (in7 - in8) * 5.1011486f;	// 0.5/cos(15 * PI/32)

	//DCT8
	//{
		//>>>>e 用DCT4计算DCT8的输出[0..7]的偶数下标元素.
	out3 = d8_0 + d8_7;
	out7 = d8_1 + d8_6;
	out11 = d8_2 + d8_5;
	out15 = d8_3 + d8_4;

	//>>e DCT2
	ein0 = out3 + out15;
	ein1 = out7 + out11;
	out1 = ein0 + ein1;
	out9 = (ein0 - ein1) * 0.7071068f;		// 0.5/cos(PI/4)

	//>>o DCT2
	oin0 = (out3 - out15) * 0.5411961f;	// 0.5/cos( PI/8)
	oin1 = (out7 - out11) * 1.3065630f;	// 0.5/cos(3PI/8)

	out5 = oin0 + oin1;
	out13 = (oin0 - oin1) * 0.7071068f;	// cos(PI/4)

	out5 += out13;
	//<<<<e 完成计算DCT8的输出[0..7]的偶数下标元素

	//>>>>o 用DCT4计算DCT8的输出[0..7]的奇数下标元素
	//o DCT4 part1
	out3 = (d8_0 - d8_7) * 0.5097956f;	// 0.5/cos( PI/16)
	out7 = (d8_1 - d8_6) * 0.6013449f;	// 0.5/cos(3PI/16)
	out11 = (d8_2 - d8_5) * 0.8999762f;	// 0.5/cos(5PI/16)
	out15 = (d8_3 - d8_4) * 2.5629154f;	// 0.5/cos(7PI/16)

	//o DCT4 part2

	//e DCT2 part1
	ein0 = out3 + out15;
	ein1 = out7 + out11;

	//o DCT2 part1
	oin0 = (out3 - out15) * 0.5411961f;	// 0.5/cos(PI/8)
	oin1 = (out7 - out11) * 1.3065630f;	// 0.5/cos(3PI/8)

	//e DCT2 part2
	out3 = ein0 + ein1;
	out11 = (ein0 - ein1) * 0.7071068f;	// cos(PI/4)

	//o DCT2 part2
	out7 = oin0 + oin1;
	out15 = (oin0 - oin1) * 0.7071068f;	// cos(PI/4)
	out7 += out15;

	//o DCT4 part3
	out3 += out7;
	out7 += out11;
	out11 += out15;
	//<<<<o 完成计算DCT8的输出[0..7]的奇数下标元素
//}

	out[i + 46] = out[i + 50] = -out1 - out3;	//out1 += out3
	out[i + 42] = out[i + 54] = -out3 - out5;	//out3 += out5
	out[i + 38] = out[i + 58] = -out5 - out7;	//out5 += out7
	out[i + 34] = out[i + 62] = -out7 - out9;	//out7 += out9
	out[i + 2] = out9 + out11;					//out9 += out11
	out[i + 6] = out11 + out13;				//out11 += out13
	out[i + 10] = out13 + out15;				//out13 += out15
	//<<<<<<<< 完成计算DCT16输出[0..15]的奇数下标元素
//}
	out[i + 14] = out15;	//out[i + 14]=out32[30]
	//<<<<<<<<<<<<<<<<
	// 完成计算DCT32输出[0..31]的偶数下标元素

	//=====================================================================

	//>>>>>>>>>>>>>>>>
	// 用DCT16计算DCT32输出[0..31]的奇数下标元素
	in0 = (in[0] - in[31]) * 0.5006030f;	// 0.5/cos( 1 * PI/64)
	in1 = (in[1] - in[30]) * 0.5054710f;	// 0.5/cos( 3 * PI/64)
	in2 = (in[2] - in[29]) * 0.5154473f;	// 0.5/cos( 5 * PI/64)
	in3 = (in[3] - in[28]) * 0.5310426f;	// 0.5/cos( 7 * PI/64)
	in4 = (in[4] - in[27]) * 0.5531039f;	// 0.5/cos( 9 * PI/64)
	in5 = (in[5] - in[26]) * 0.5829350f;	// 0.5/cos(11 * PI/64)
	in6 = (in[6] - in[25]) * 0.6225041f;	// 0.5/cos(13 * PI/64)
	in7 = (in[7] - in[24]) * 0.6748083f;	// 0.5/cos(15 * PI/64)
	in8 = (in[8] - in[23]) * 0.7445362f;	// 0.5/cos(17 * PI/64)
	in9 = (in[9] - in[22]) * 0.8393496f;	// 0.5/cos(19 * PI/64)
	in10 = (in[10] - in[21]) * 0.9725682f;	// 0.5/cos(21 * PI/64)
	in11 = (in[11] - in[20]) * 1.1694399f;	// 0.5/cos(23 * PI/64)
	in12 = (in[12] - in[19]) * 1.4841646f;	// 0.5/cos(25 * PI/64)
	in13 = (in[13] - in[18]) * 2.0577810f;	// 0.5/cos(27 * PI/64)
	in14 = (in[14] - in[17]) * 3.4076084f;	// 0.5/cos(29 * PI/64)
	in15 = (in[15] - in[16]) * 10.190008f;	// 0.5/cos(31 * PI/64)

	//DCT16
	//{
		//>>>>>>>> 用DCT8计算DCT16输出[0..15]的偶数下标元素
	d8_0 = in0 + in15;
	d8_1 = in1 + in14;
	d8_2 = in2 + in13;
	d8_3 = in3 + in12;
	d8_4 = in4 + in11;
	d8_5 = in5 + in10;
	d8_6 = in6 + in9;
	d8_7 = in7 + in8;

	//DCT8
	//{
		//>>>>e 用DCT4计算DCT8的输出[0..7]的偶数下标元素
	out1 = d8_0 + d8_7;
	out3 = d8_1 + d8_6;
	out5 = d8_2 + d8_5;
	out7 = d8_3 + d8_4;

	//>>e DCT2
	ein0 = out1 + out7;
	ein1 = out3 + out5;
	out0 = ein0 + ein1;
	out8 = (ein0 - ein1) * 0.7071068f;	// 0.5/cos(PI/4)

	//>>o DCT2
	oin0 = (out1 - out7) * 0.5411961f;	// 0.5/cos( PI/8)
	oin1 = (out3 - out5) * 1.3065630f;	// 0.5/cos(3PI/8)

	out4 = oin0 + oin1;
	out12 = (oin0 - oin1) * 0.7071068f;// cos(PI/4)

	out4 += out12;
	//<<<<e 完成计算DCT8的输出[0..7]的偶数下标元素

	//>>>>o 用DCT4计算DCT8的输出[0..7]的奇数下标元素
	//o DCT4 part1
	out1 = (d8_0 - d8_7) * 0.5097956f;	// 0.5/cos( PI/16)
	out3 = (d8_1 - d8_6) * 0.6013449f;	// 0.5/cos(3PI/16)
	out5 = (d8_2 - d8_5) * 0.8999762f;	// 0.5/cos(5PI/16)
	out7 = (d8_3 - d8_4) * 2.5629154f;	// 0.5/cos(7PI/16)

	//o DCT4 part2

	//e DCT2 part1
	ein0 = out1 + out7;
	ein1 = out3 + out5;

	//o DCT2 part1
	oin0 = (out1 - out7) * 0.5411961f;	// 0.5/cos(PI/8)
	oin1 = (out3 - out5) * 1.3065630f;	// 0.5/cos(3PI/8)

	//e DCT2 part2
	out2 = ein0 + ein1;
	out10 = (ein0 - ein1) * 0.7071068f;// cos(PI/4)

	//o DCT2 part2
	out6 = oin0 + oin1;
	out14 = (oin0 - oin1) * 0.7071068f;
	out6 += out14;

	//o DCT4 part3
	out2 += out6;
	out6 += out10;
	out10 += out14;
	//<<<<o 完成计算DCT8的输出[0..7]的奇数下标元素
//}
//<<<<<<<< 完成计算DCT16输出[0..15]的偶数下标元素

//-----------------------------------------------------------------

//>>>>>>>> 用DCT8计算DCT16输出[0..15]的奇数下标元素
	d8_0 = (in0 - in15) * 0.5024193f;	// 0.5/cos( 1 * PI/32)
	d8_1 = (in1 - in14) * 0.5224986f;	// 0.5/cos( 3 * PI/32)
	d8_2 = (in2 - in13) * 0.5669440f;	// 0.5/cos( 5 * PI/32)
	d8_3 = (in3 - in12) * 0.6468218f;	// 0.5/cos( 7 * PI/32)
	d8_4 = (in4 - in11) * 0.7881546f;	// 0.5/cos( 9 * PI/32)
	d8_5 = (in5 - in10) * 1.0606777f;	// 0.5/cos(11 * PI/32)
	d8_6 = (in6 - in9) * 1.7224471f;	// 0.5/cos(13 * PI/32)
	d8_7 = (in7 - in8) * 5.1011486f;	// 0.5/cos(15 * PI/32)

	//DCT8
	//{
		//>>>>e 用DCT4计算DCT8的输出[0..7]的偶数下标元素.
	out1 = d8_0 + d8_7;
	out3 = d8_1 + d8_6;
	out5 = d8_2 + d8_5;
	out7 = d8_3 + d8_4;

	//>>e DCT2
	ein0 = out1 + out7;
	ein1 = out3 + out5;
	in0 = ein0 + ein1;	//out0->in0,out4->in4
	in4 = (ein0 - ein1) * 0.7071068f;	// 0.5/cos(PI/4)

	//>>o DCT2
	oin0 = (out1 - out7) * 0.5411961f;	// 0.5/cos( PI/8)
	oin1 = (out3 - out5) * 1.3065630f;	// 0.5/cos(3PI/8)

	in2 = oin0 + oin1;					//out2->in2,out6->in6
	in6 = (oin0 - oin1) * 0.7071068f;	// cos(PI/4)

	in2 += in6;
	//<<<<e 完成计算DCT8的输出[0..7]的偶数下标元素

	//>>>>o 用DCT4计算DCT8的输出[0..7]的奇数下标元素
	//o DCT4 part1
	out1 = (d8_0 - d8_7) * 0.5097956f;	// 0.5/cos( PI/16)
	out3 = (d8_1 - d8_6) * 0.6013449f;	// 0.5/cos(3PI/16)
	out5 = (d8_2 - d8_5) * 0.8999762f;	// 0.5/cos(5PI/16)
	out7 = (d8_3 - d8_4) * 2.5629154f;	// 0.5/cos(7PI/16)

	//o DCT4 part2

	//e DCT2 part1
	ein0 = out1 + out7;
	ein1 = out3 + out5;

	//o DCT2 part1
	oin0 = (out1 - out7) * 0.5411961f;	// 0.5/cos(PI/8)
	oin1 = (out3 - out5) * 1.3065630f;	// 0.5/cos(3PI/8)

	//e DCT2 part2
	out1 = ein0 + ein1;
	out5 = (ein0 - ein1) * 0.7071068f;	// cos(PI/4)

	//o DCT2 part2
	out3 = oin0 + oin1;
	out15 = (oin0 - oin1) * 0.7071068f;
	out3 += out15;

	//o DCT4 part3
	out1 += out3;
	out3 += out5;
	out5 += out15;
	//<<<<o 完成计算DCT8的输出[0..7]的奇数下标元素
//}
						//out15=out7
	out13 = in6 + out15;	//out13=out6+out7
	out11 = out5 + in6;		//out11=out5+out6
	out9 = in4 + out5;		//out9 =out4+out5
	out7 = out3 + in4;		//out7 =out3+out4
	out5 = in2 + out3;		//out5 =out2+out3
	out3 = out1 + in2;		//out3 =out1+out2
	out1 += in0;			//out1 =out0+out1
	//<<<<<<<< 完成计算DCT16输出[0..15]的奇数下标元素
//}

//DCT32out[i]=out[i]+out[i+1]; DCT32out[31]=out[15]
	out[i + 47] = out[i + 49] = -out0 - out1;
	out[i + 45] = out[i + 51] = -out1 - out2;
	out[i + 43] = out[i + 53] = -out2 - out3;
	out[i + 41] = out[i + 55] = -out3 - out4;
	out[i + 39] = out[i + 57] = -out4 - out5;
	out[i + 37] = out[i + 59] = -out5 - out6;
	out[i + 35] = out[i + 61] = -out6 - out7;
	out[i + 33] = out[i + 63] = -out7 - out8;
	out[i + 1] = out8 + out9;
	out[i + 3] = out9 + out10;
	out[i + 5] = out10 + out11;
	out[i + 7] = out11 + out12;
	out[i + 9] = out12 + out13;
	out[i + 11] = out13 + out14;
	out[i + 13] = out14 + out15;
	out[i + 15] = out15;
	//<<<<<<<<<<<<<<<<

	out[i + 16] = 0;

	out[i + 17] = -out15;	//out[i + 17] = -out[i + 15]
	out[i + 18] = -out[i + 14];
	out[i + 19] = -out[i + 13];
	out[i + 20] = -out[i + 12];
	out[i + 21] = -out[i + 11];
	out[i + 22] = -out[i + 10];
	out[i + 23] = -out[i + 9];
	out[i + 24] = -out[i + 8];
	out[i + 25] = -out[i + 7];
	out[i + 26] = -out[i + 6];
	out[i + 27] = -out[i + 5];
	out[i + 28] = -out[i + 4];
	out[i + 29] = -out[i + 3];
	out[i + 30] = -out[i + 2];
	out[i + 31] = -out[i + 1];
	out[i + 32] = -out[i];
}

static float fifo_pcm_out[2][1024];
static unsigned fifo_index[2];

//int synthesisSubBand(float* samples, int ch, unsigned char* bu, int of, int nch)
void synthesis_subband_filter(const float samples_in[32], unsigned char pcm_out[32 * 2 * 2], unsigned pcm_out_index[2], int ch, int nch)
{
	float* fifo = fifo_pcm_out[ch];
	float sum;
	const float* win;
	int i;
	short pcmi;
	/*
	 * 向PCM缓冲区写入数据的步长值，左右声道的PCM数据在PCM缓冲区内是交替排列的。
	 * 指示解码某一声道时写入一次数据后，下一次应该写入的位置。
	 */
	int step = (nch == 2) ? 4 : 2;

	//1. Shift
	fifo_index[ch] = (fifo_index[ch] - 64) & 0x3FF;
	//960,896,832,768,704,640,576,512,448,384,320,256,192,128,64,0

	//2. Matrixing
	dct32to64(samples_in, fifo, fifo_index[ch]);

	//3. Build the U vector
	//4. Dewindowing
	//5. Calculate and output 32 samples
	switch (fifo_index[ch]) {
	case 0:
		//u_vector={0,96,128,224,256,352,384,480,512,608,640,736,768,864,896,992}=u_base
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i];
			sum += win[1] * fifo[i + 96];
			sum += win[2] * fifo[i + 128];
			sum += win[3] * fifo[i + 224];
			sum += win[4] * fifo[i + 256];
			sum += win[5] * fifo[i + 352];
			sum += win[6] * fifo[i + 384];
			sum += win[7] * fifo[i + 480];
			sum += win[8] * fifo[i + 512];
			sum += win[9] * fifo[i + 608];
			sum += win[10] * fifo[i + 640];
			sum += win[11] * fifo[i + 736];
			sum += win[12] * fifo[i + 768];
			sum += win[13] * fifo[i + 864];
			sum += win[14] * fifo[i + 896];
			sum += win[15] * fifo[i + 992];
			pcmi = sum > 32767.0 ? 32767 : (sum < -32768.0 ? -32768 : (short)sum); //clip
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 64:
		//u_vector={64,160,192,288,320,416,448,544,576,672,704,800,832,928,960,32}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 64];
			sum += win[1] * fifo[i + 160];
			sum += win[2] * fifo[i + 192];
			sum += win[3] * fifo[i + 288];
			sum += win[4] * fifo[i + 320];
			sum += win[5] * fifo[i + 416];
			sum += win[6] * fifo[i + 448];
			sum += win[7] * fifo[i + 544];
			sum += win[8] * fifo[i + 576];
			sum += win[9] * fifo[i + 672];
			sum += win[10] * fifo[i + 704];
			sum += win[11] * fifo[i + 800];
			sum += win[12] * fifo[i + 832];
			sum += win[13] * fifo[i + 928];
			sum += win[14] * fifo[i + 960];
			sum += win[15] * fifo[i + 32];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 128:
		//u_vector={128,224,256,352,384,480,512,608,640,736,768,864,896,992,0,96}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 128];
			sum += win[1] * fifo[i + 224];
			sum += win[2] * fifo[i + 256];
			sum += win[3] * fifo[i + 352];
			sum += win[4] * fifo[i + 384];
			sum += win[5] * fifo[i + 480];
			sum += win[6] * fifo[i + 512];
			sum += win[7] * fifo[i + 608];
			sum += win[8] * fifo[i + 640];
			sum += win[9] * fifo[i + 736];
			sum += win[10] * fifo[i + 768];
			sum += win[11] * fifo[i + 864];
			sum += win[12] * fifo[i + 896];
			sum += win[13] * fifo[i + 992];
			sum += win[14] * fifo[i];
			sum += win[15] * fifo[i + 96];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 192:
		//u_vector={192,288,320,416,448,544,576,672,704,800,832,928,960,32,64,160}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 192];
			sum += win[1] * fifo[i + 288];
			sum += win[2] * fifo[i + 320];
			sum += win[3] * fifo[i + 416];
			sum += win[4] * fifo[i + 448];
			sum += win[5] * fifo[i + 544];
			sum += win[6] * fifo[i + 576];
			sum += win[7] * fifo[i + 672];
			sum += win[8] * fifo[i + 704];
			sum += win[9] * fifo[i + 800];
			sum += win[10] * fifo[i + 832];
			sum += win[11] * fifo[i + 928];
			sum += win[12] * fifo[i + 960];
			sum += win[13] * fifo[i + 32];
			sum += win[14] * fifo[i + 64];
			sum += win[15] * fifo[i + 160];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 256:
		//u_vector={256,352,384,480,512,608,640,736,768,864,896,992,0,96,128,224}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 256];
			sum += win[1] * fifo[i + 352];
			sum += win[2] * fifo[i + 384];
			sum += win[3] * fifo[i + 480];
			sum += win[4] * fifo[i + 512];
			sum += win[5] * fifo[i + 608];
			sum += win[6] * fifo[i + 640];
			sum += win[7] * fifo[i + 736];
			sum += win[8] * fifo[i + 768];
			sum += win[9] * fifo[i + 864];
			sum += win[10] * fifo[i + 896];
			sum += win[11] * fifo[i + 992];
			sum += win[12] * fifo[i];
			sum += win[13] * fifo[i + 96];
			sum += win[14] * fifo[i + 128];
			sum += win[15] * fifo[i + 224];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 320:
		//u_vector={320,416,448,544,576,672,704,800,832,928,960,32,64,160,192,288}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 320];
			sum += win[1] * fifo[i + 416];
			sum += win[2] * fifo[i + 448];
			sum += win[3] * fifo[i + 544];
			sum += win[4] * fifo[i + 576];
			sum += win[5] * fifo[i + 672];
			sum += win[6] * fifo[i + 704];
			sum += win[7] * fifo[i + 800];
			sum += win[8] * fifo[i + 832];
			sum += win[9] * fifo[i + 928];
			sum += win[10] * fifo[i + 960];
			sum += win[11] * fifo[i + 32];
			sum += win[12] * fifo[i + 64];
			sum += win[13] * fifo[i + 160];
			sum += win[14] * fifo[i + 192];
			sum += win[15] * fifo[i + 288];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 384:
		//u_vector={384,480,512,608,640,736,768,864,896,992,0,96,128,224,256,352}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 384];
			sum += win[1] * fifo[i + 480];
			sum += win[2] * fifo[i + 512];
			sum += win[3] * fifo[i + 608];
			sum += win[4] * fifo[i + 640];
			sum += win[5] * fifo[i + 736];
			sum += win[6] * fifo[i + 768];
			sum += win[7] * fifo[i + 864];
			sum += win[8] * fifo[i + 896];
			sum += win[9] * fifo[i + 992];
			sum += win[10] * fifo[i];
			sum += win[11] * fifo[i + 96];
			sum += win[12] * fifo[i + 128];
			sum += win[13] * fifo[i + 224];
			sum += win[14] * fifo[i + 256];
			sum += win[15] * fifo[i + 352];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 448:
		//u_vector={448,544,576,672,704,800,832,928,960,32,64,160,192,288,320,416}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 448];
			sum += win[1] * fifo[i + 544];
			sum += win[2] * fifo[i + 576];
			sum += win[3] * fifo[i + 672];
			sum += win[4] * fifo[i + 704];
			sum += win[5] * fifo[i + 800];
			sum += win[6] * fifo[i + 832];
			sum += win[7] * fifo[i + 928];
			sum += win[8] * fifo[i + 960];
			sum += win[9] * fifo[i + 32];
			sum += win[10] * fifo[i + 64];
			sum += win[11] * fifo[i + 160];
			sum += win[12] * fifo[i + 192];
			sum += win[13] * fifo[i + 288];
			sum += win[14] * fifo[i + 320];
			sum += win[15] * fifo[i + 416];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 512:
		//u_vector={512,608,640,736,768,864,896,992,0,96,128,224,256,352,384,480}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 512];
			sum += win[1] * fifo[i + 608];
			sum += win[2] * fifo[i + 640];
			sum += win[3] * fifo[i + 736];
			sum += win[4] * fifo[i + 768];
			sum += win[5] * fifo[i + 864];
			sum += win[6] * fifo[i + 896];
			sum += win[7] * fifo[i + 992];
			sum += win[8] * fifo[i];
			sum += win[9] * fifo[i + 96];
			sum += win[10] * fifo[i + 128];
			sum += win[11] * fifo[i + 224];
			sum += win[12] * fifo[i + 256];
			sum += win[13] * fifo[i + 352];
			sum += win[14] * fifo[i + 384];
			sum += win[15] * fifo[i + 480];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 576:
		//u_vector={576,672,704,800,832,928,960,32,64,160,192,288,320,416,448,544}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 576];
			sum += win[1] * fifo[i + 672];
			sum += win[2] * fifo[i + 704];
			sum += win[3] * fifo[i + 800];
			sum += win[4] * fifo[i + 832];
			sum += win[5] * fifo[i + 928];
			sum += win[6] * fifo[i + 960];
			sum += win[7] * fifo[i + 32];
			sum += win[8] * fifo[i + 64];
			sum += win[9] * fifo[i + 160];
			sum += win[10] * fifo[i + 192];
			sum += win[11] * fifo[i + 288];
			sum += win[12] * fifo[i + 320];
			sum += win[13] * fifo[i + 416];
			sum += win[14] * fifo[i + 448];
			sum += win[15] * fifo[i + 544];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 640:
		//u_vector={640,736,768,864,896,992,0,96,128,224,256,352,384,480,512,608}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 640];
			sum += win[1] * fifo[i + 736];
			sum += win[2] * fifo[i + 768];
			sum += win[3] * fifo[i + 864];
			sum += win[4] * fifo[i + 896];
			sum += win[5] * fifo[i + 992];
			sum += win[6] * fifo[i];
			sum += win[7] * fifo[i + 96];
			sum += win[8] * fifo[i + 128];
			sum += win[9] * fifo[i + 224];
			sum += win[10] * fifo[i + 256];
			sum += win[11] * fifo[i + 352];
			sum += win[12] * fifo[i + 384];
			sum += win[13] * fifo[i + 480];
			sum += win[14] * fifo[i + 512];
			sum += win[15] * fifo[i + 608];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 704:
		//u_vector={704,800,832,928,960,32,64,160,192,288,320,416,448,544,576,672}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 704];
			sum += win[1] * fifo[i + 800];
			sum += win[2] * fifo[i + 832];
			sum += win[3] * fifo[i + 928];
			sum += win[4] * fifo[i + 960];
			sum += win[5] * fifo[i + 32];
			sum += win[6] * fifo[i + 64];
			sum += win[7] * fifo[i + 160];
			sum += win[8] * fifo[i + 192];
			sum += win[9] * fifo[i + 288];
			sum += win[10] * fifo[i + 320];
			sum += win[11] * fifo[i + 416];
			sum += win[12] * fifo[i + 448];
			sum += win[13] * fifo[i + 544];
			sum += win[14] * fifo[i + 576];
			sum += win[15] * fifo[i + 672];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 768:
		//u_vector={768,864,896,992,0,96,128,224,256,352,384,480,512,608,640,736}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 768];
			sum += win[1] * fifo[i + 864];
			sum += win[2] * fifo[i + 896];
			sum += win[3] * fifo[i + 992];
			sum += win[4] * fifo[i];
			sum += win[5] * fifo[i + 96];
			sum += win[6] * fifo[i + 128];
			sum += win[7] * fifo[i + 224];
			sum += win[8] * fifo[i + 256];
			sum += win[9] * fifo[i + 352];
			sum += win[10] * fifo[i + 384];
			sum += win[11] * fifo[i + 480];
			sum += win[12] * fifo[i + 512];
			sum += win[13] * fifo[i + 608];
			sum += win[14] * fifo[i + 640];
			sum += win[15] * fifo[i + 736];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 832:
		//u_vector={832,928,960,32,64,160,192,288,320,416,448,544,576,672,704,800}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 832];
			sum += win[1] * fifo[i + 928];
			sum += win[2] * fifo[i + 960];
			sum += win[3] * fifo[i + 32];
			sum += win[4] * fifo[i + 64];
			sum += win[5] * fifo[i + 160];
			sum += win[6] * fifo[i + 192];
			sum += win[7] * fifo[i + 288];
			sum += win[8] * fifo[i + 320];
			sum += win[9] * fifo[i + 416];
			sum += win[10] * fifo[i + 448];
			sum += win[11] * fifo[i + 544];
			sum += win[12] * fifo[i + 576];
			sum += win[13] * fifo[i + 672];
			sum += win[14] * fifo[i + 704];
			sum += win[15] * fifo[i + 800];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 896:
		//u_vector={896,992,0,96,128,224,256,352,384,480,512,608,640,736,768,864}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 896];
			sum += win[1] * fifo[i + 992];
			sum += win[2] * fifo[i];
			sum += win[3] * fifo[i + 96];
			sum += win[4] * fifo[i + 128];
			sum += win[5] * fifo[i + 224];
			sum += win[6] * fifo[i + 256];
			sum += win[7] * fifo[i + 352];
			sum += win[8] * fifo[i + 384];
			sum += win[9] * fifo[i + 480];
			sum += win[10] * fifo[i + 512];
			sum += win[11] * fifo[i + 608];
			sum += win[12] * fifo[i + 640];
			sum += win[13] * fifo[i + 736];
			sum += win[14] * fifo[i + 768];
			sum += win[15] * fifo[i + 864];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)sum);
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)((unsigned short)pcmi >> 8);
		}
		break;
	case 960:
		//u_vector={960,32,64,160,192,288,320,416,448,544,576,672,704,800,832,928}
		for (i = 0; i < 32; i++, pcm_out_index[ch] += step) {
			win = dewin[i];
			sum = win[0] * fifo[i + 960];
			sum += win[1] * fifo[i + 32];
			sum += win[2] * fifo[i + 64];
			sum += win[3] * fifo[i + 160];
			sum += win[4] * fifo[i + 192];
			sum += win[5] * fifo[i + 288];
			sum += win[6] * fifo[i + 320];
			sum += win[7] * fifo[i + 416];
			sum += win[8] * fifo[i + 448];
			sum += win[9] * fifo[i + 544];
			sum += win[10] * fifo[i + 576];
			sum += win[11] * fifo[i + 672];
			sum += win[12] * fifo[i + 704];
			sum += win[13] * fifo[i + 800];
			sum += win[14] * fifo[i + 832];
			sum += win[15] * fifo[i + 928];
			pcmi = sum > 32767 ? 32767 : (sum < -32768 ? -32768 : (short)(sum + 0.5));
			pcm_out[pcm_out_index[ch]] = (unsigned char)pcmi;
			pcm_out[pcm_out_index[ch] + 1] = (unsigned char)(pcmi >> 8);
		}
		break;
	}
}

#endif

/*
coefficients Di for the synthesis window
*/
static float _D[512] =
{
	0.000000000, -0.000015259, -0.000015259, -0.000015259,
	-0.000015259, -0.000015259, -0.000015259, -0.000030518,
	-0.000030518, -0.000030518, -0.000030518, -0.000045776,
	-0.000045776, -0.000061035, -0.000061035, -0.000076294,
	-0.000076294, -0.000091553, -0.000106812, -0.000106812,
	-0.000122070, -0.000137329, -0.000152588, -0.000167847,
	-0.000198364, -0.000213623, -0.000244141, -0.000259399,
	-0.000289917, -0.000320435, -0.000366211, -0.000396729,
	-0.000442505, -0.000473022, -0.000534058, -0.000579834,
	-0.000625610, -0.000686646, -0.000747681, -0.000808716,
	-0.000885010, -0.000961304, -0.001037598, -0.001113892,
	-0.001205444, -0.001296997, -0.001388550, -0.001480103,
	-0.001586914, -0.001693726, -0.001785278, -0.001907349,
	-0.002014160, -0.002120972, -0.002243042, -0.002349854,
	-0.002456665, -0.002578735, -0.002685547, -0.002792358,
	-0.002899170, -0.002990723, -0.003082275, -0.003173828,
	0.003250122, 0.003326416, 0.003387451, 0.003433228,
	0.003463745, 0.003479004, 0.003479004, 0.003463745,
	0.003417969, 0.003372192, 0.003280640, 0.003173828,
	0.003051758, 0.002883911, 0.002700806, 0.002487183,
	0.002227783, 0.001937866, 0.001617432, 0.001266479,
	0.000869751, 0.000442505, -0.000030518, -0.000549316,
	-0.001098633, -0.001693726, -0.002334595, -0.003005981,
	-0.003723145, -0.004486084, -0.005294800, -0.006118774,
	-0.007003784, -0.007919312, -0.008865356, -0.009841919,
	-0.010848999, -0.011886597, -0.012939453, -0.014022827,
	-0.015121460, -0.016235352, -0.017349243, -0.018463135,
	-0.019577026, -0.020690918, -0.021789551, -0.022857666,
	-0.023910522, -0.024932861, -0.025909424, -0.026840210,
	-0.027725220, -0.028533936, -0.029281616, -0.029937744,
	-0.030532837, -0.031005859, -0.031387329, -0.031661987,
	-0.031814575, -0.031845093, -0.031738281, -0.031478882,
	0.031082153, 0.030517578, 0.029785156, 0.028884888,
	0.027801514, 0.026535034, 0.025085449, 0.023422241,
	0.021575928, 0.019531250, 0.017257690, 0.014801025,
	0.012115479, 0.009231567, 0.006134033, 0.002822876,
	-0.000686646, -0.004394531, -0.008316040, -0.012420654,
	-0.016708374, -0.021179199, -0.025817871, -0.030609131,
	-0.035552979, -0.040634155, -0.045837402, -0.051132202,
	-0.056533813, -0.061996460, -0.067520142, -0.073059082,
	-0.078628540, -0.084182739, -0.089706421, -0.095169067,
	-0.100540161, -0.105819702, -0.110946655, -0.115921021,
	-0.120697021, -0.125259399, -0.129562378, -0.133590698,
	-0.137298584, -0.140670776, -0.143676758, -0.146255493,
	-0.148422241, -0.150115967, -0.151306152, -0.151962280,
	-0.152069092, -0.151596069, -0.150497437, -0.148773193,
	-0.146362305, -0.143264771, -0.139450073, -0.134887695,
	-0.129577637, -0.123474121, -0.116577148, -0.108856201,
	0.100311279, 0.090927124, 0.080688477, 0.069595337,
	0.057617187, 0.044784546, 0.031082153, 0.016510010,
	0.001068115, -0.015228271, -0.032379150, -0.050354004,
	-0.069168091, -0.088775635, -0.109161377, -0.130310059,
	-0.152206421, -0.174789429, -0.198059082, -0.221984863,
	-0.246505737, -0.271591187, -0.297210693, -0.323318481,
	-0.349868774, -0.376800537, -0.404083252, -0.431655884,
	-0.459472656, -0.487472534, -0.515609741, -0.543823242,
	-0.572036743, -0.600219727, -0.628295898, -0.656219482,
	-0.683914185, -0.711318970, -0.738372803, -0.765029907,
	-0.791213989, -0.816864014, -0.841949463, -0.866363525,
	-0.890090942, -0.913055420, -0.935195923, -0.956481934,
	-0.976852417, -0.996246338, -1.014617920, -1.031936646,
	-1.048156738, -1.063217163, -1.077117920, -1.089782715,
	-1.101211548, -1.111373901, -1.120223999, -1.127746582,
	-1.133926392, -1.138763428, -1.142211914, -1.144287109,
	1.144989014, 1.144287109, 1.142211914, 1.138763428,
	1.133926392, 1.127746582, 1.120223999, 1.111373901,
	1.101211548, 1.089782715, 1.077117920, 1.063217163,
	1.048156738, 1.031936646, 1.014617920, 0.996246338,
	0.976852417, 0.956481934, 0.935195923, 0.913055420,
	0.890090942, 0.866363525, 0.841949463, 0.816864014,
	0.791213989, 0.765029907, 0.738372803, 0.711318970,
	0.683914185, 0.656219482, 0.628295898, 0.600219727,
	0.572036743, 0.543823242, 0.515609741, 0.487472534,
	0.459472656, 0.431655884, 0.404083252, 0.376800537,
	0.349868774, 0.323318481, 0.297210693, 0.271591187,
	0.246505737, 0.221984863, 0.198059082, 0.174789429,
	0.152206421, 0.130310059, 0.109161377, 0.088775635,
	0.069168091, 0.050354004, 0.032379150, 0.015228271,
	-0.001068115, -0.016510010, -0.031082153, -0.044784546,
	-0.057617187, -0.069595337, -0.080688477, -0.090927124,
	0.100311279, 0.108856201, 0.116577148, 0.123474121,
	0.129577637, 0.134887695, 0.139450073, 0.143264771,
	0.146362305, 0.148773193, 0.150497437, 0.151596069,
	0.152069092, 0.151962280, 0.151306152, 0.150115967,
	0.148422241, 0.146255493, 0.143676758, 0.140670776,
	0.137298584, 0.133590698, 0.129562378, 0.125259399,
	0.120697021, 0.115921021, 0.110946655, 0.105819702,
	0.100540161, 0.095169067, 0.089706421, 0.084182739,
	0.078628540, 0.073059082, 0.067520142, 0.061996460,
	0.056533813, 0.051132202, 0.045837402, 0.040634155,
	0.035552979, 0.030609131, 0.025817871, 0.021179199,
	0.016708374, 0.012420654, 0.008316040, 0.004394531,
	0.000686646, -0.002822876, -0.006134033, -0.009231567,
	-0.012115479, -0.014801025, -0.017257690, -0.019531250,
	-0.021575928, -0.023422241, -0.025085449, -0.026535034,
	-0.027801514, -0.028884888, -0.029785156, -0.030517578,
	0.031082153, 0.031478882, 0.031738281, 0.031845093,
	0.031814575, 0.031661987, 0.031387329, 0.031005859,
	0.030532837, 0.029937744, 0.029281616, 0.028533936,
	0.027725220, 0.026840210, 0.025909424, 0.024932861,
	0.023910522, 0.022857666, 0.021789551, 0.020690918,
	0.019577026, 0.018463135, 0.017349243, 0.016235352,
	0.015121460, 0.014022827, 0.012939453, 0.011886597,
	0.010848999, 0.009841919, 0.008865356, 0.007919312,
	0.007003784, 0.006118774, 0.005294800, 0.004486084,
	0.003723145, 0.003005981, 0.002334595, 0.001693726,
	0.001098633, 0.000549316, 0.000030518, -0.000442505,
	-0.000869751, -0.001266479, -0.001617432, -0.001937866,
	-0.002227783, -0.002487183, -0.002700806, -0.002883911,
	-0.003051758, -0.003173828, -0.003280640, -0.003372192,
	-0.003417969, -0.003463745, -0.003479004, -0.003479004,
	-0.003463745, -0.003433228, -0.003387451, -0.003326416,
	0.003250122, 0.003173828, 0.003082275, 0.002990723,
	0.002899170, 0.002792358, 0.002685547, 0.002578735,
	0.002456665, 0.002349854, 0.002243042, 0.002120972,
	0.002014160, 0.001907349, 0.001785278, 0.001693726,
	0.001586914, 0.001480103, 0.001388550, 0.001296997,
	0.001205444, 0.001113892, 0.001037598, 0.000961304,
	0.000885010, 0.000808716, 0.000747681, 0.000686646,
	0.000625610, 0.000579834, 0.000534058, 0.000473022,
	0.000442505, 0.000396729, 0.000366211, 0.000320435,
	0.000289917, 0.000259399, 0.000244141, 0.000213623,
	0.000198364, 0.000167847, 0.000152588, 0.000137329,
	0.000122070, 0.000106812, 0.000106812, 0.000091553,
	0.000076294, 0.000076294, 0.000061035, 0.000061035,
	0.000045776, 0.000045776, 0.000030518, 0.000030518,
	0.000030518, 0.000030518, 0.000015259, 0.000015259,
	0.000015259, 0.000015259, 0.000015259, 0.000015259
};	// need init ( _D[i] *= 32768 )

/*
coefficients Nik for the synthesis window
*/
static float _N[64][32]; // need init ( _N[i][k] = cos((16+i)*(2*k+1)*PI/64) )
// static float _N[32][32]; // need init ( _N[i][k] = cos(i*(2*k+1)*PI/64) )

static float _U[512];

static float _V[2][1024];
static int _V_index[2];

static void dct32to64(const float samples_in[32], int ch)
{
	float tmp[32];
	int i;

	for (i = 0; i < 32; ++i) {
		tmp[i] = 0;
		for (int k = 0; k < 32; ++k) {
			tmp[i] += _N[i][k] * samples_in[k];
		}
	}

	for (i = 0; i < 16; ++i) {
		_V[ch][_V_index[ch] + i] = tmp[i + 16];
	}
	_V[ch][_V_index[ch] + i++] = 0;
	for (; i < 48; ++i) {
		_V[ch][_V_index[ch] + i] = -tmp[48 - i];
	}
	for (; i < 64; ++i) {
		_V[ch][_V_index[ch] + i] = -tmp[i - 48];
	}
}

#include <math.h>
#define	PI	3.14159265358979323846
void init_synthesis_tabs(void)
{
	int i;

	for (i = 0; i < 64; ++i) {
		for (int k = 0; k < 32; ++k) {
			// _N[i][k] = cos(i * (2.0 * k + 1) * PI / 64);
			_N[i][k] = cos((16.0 + i) * (2.0 * k + 1.0) * PI / 64.0);
		}
	}

	//for (i = 0; i < 512; ++i) {
	//	_D[i] *= 32768.0;
	//}
}

#if 0
/*
mono:
pcm_out[0] --> left_lo -\ PCM Sample 1
pcm_out[1] --> left_hi -/

staereo:
pcm_out[0] --> left_lo	-\
pcm_out[1] --> left_hi	->\ PCM Sample 1
pcm_out[2] --> right_lo ->/
pcm_out[3] --> right_hi -/
*/
void synthesis_subband_filter(const float samples_in[32], char pcm_out[32 * 2 * 2], unsigned pcm_out_index[2], int ch, int nch)
{
	int i, j;
	// Shifting
	_V_index[ch] = (_V_index[ch] - 64) & 0x3ff;

	// Matrixing (DCT(32 -> 64))
	for (i = 0; i < 64; ++i) {
		float t_V = 0.0;
		for (j = 0; j < 32; ++j) {
			t_V += _N[i][j] * samples_in[j];
		}
		_V[ch][_V_index[ch] + i] = t_V;
	}
	// dct32to64(samples_in, ch);

	// Build a 512 values vector U
	for (i = 0; i < 8; ++i) {
		for (j = 0; j < 32; ++j) {
			/*_U[i * 64 + j] = _V[ch][i * 128 + j];
			_U[i * 64 + 32 + j] = _V[ch][i * 128 + 96 + j];*/
			_W[i * 64 + j] = _V[ch][i * 128 + j];
			_W[i * 64 + j + 32] = _V[ch][i * 128 + j + 96];
		}
	}
	//for (int i = 0; i < 512; i += 64) {
	//	for (int j = 0; j < 32; ++j) {
	//		_U[i + j] = _V[ch][i * 2 + j];
	//		_U[i + j + 32] = _V[ch][i * 2 + j + 96];
	//	}
	//}

	// Window by 512 coefficients
	for (i = 0; i < 512; ++i) {
		/*_W[i] = _U[i] * _D[i];*/
		_W[i] *= _D[i];
	}

	//// Build a 512 values vector U
	//// Window by 512 coefficients
	//for (int i = 0; i < 512; i += 64) {
	//	for (int j = 0; j < 32; ++j) {
	//		_W[i + j] = _V[ch][i * 2 + j] * _D[i + j];
	//		_W[i + j + 32] = _V[ch][i * 2 + j + 96] * _D[i + j];
	//	}
	//}

	// Calculate 32 Samples
	//unsigned step = nch << 1;
	//for (int i = 0; i < 32; ++i) {
	//	float t_S = 0;
	//	for (int j = 0; j < 16; ++j) {
	//		t_S += _W[i + 32 * j];
	//	}
	//	// Output 32 reconstructed PCM Samples
	//	pcm_out[pcm_out_index[ch]] = ((char*)&t_S)[0];
	//	pcm_out[pcm_out_index[ch] + 1] = ((char*)&t_S)[1];
	//	pcm_out_index[ch] += step;
	//}
	unsigned step = nch << 1;
	for (i = 0; i < 32; ++i) {
		float t_S = 0;
		for (j = 0; j < 512; j += 32) {
			t_S += _W[i + j];
		}
		// t_S *= 32767.0;
		// Output 32 reconstructed PCM Samples
		short pcm_i;
		if (t_S > 32767.0) {
			/*pcm_out[pcm_out_index[ch]] = 0xf;
			pcm_out[pcm_out_index[ch] + 1] = 0x7;*/
			pcm_i = 32767;
		} else if (t_S < -32768.0) {
			/*pcm_out[pcm_out_index[ch]] = 0;
			pcm_out[pcm_out_index[ch] + 1] = 0x80;*/
			pcm_i = -32768;
		} else {
			pcm_i = (short)(t_S + 0.5);
			// memcpy(&pcm_i, &t_S, 2);
			/*pcm_out[pcm_out_index[ch]] = (char)pcm_i;
			pcm_out[pcm_out_index[ch] + 1] = (char)((pcm_i >> 8) & 0xff);*/
		}
		// pcm_i >>= 1;
		//pcm_out[pcm_out_index[ch]] = (char)pcm_i;
		//pcm_out[pcm_out_index[ch] + 1] = (char)(pcm_i >> 8);
		/**(short*)(pcm_out + pcm_out_index[ch]) = *(short*)&pcm_i;*/
		pcm_out[pcm_out_index[ch]] = (char)pcm_i;
		pcm_out[pcm_out_index[ch] + 1] = (char)(pcm_i >> 8);
		pcm_out_index[ch] += step;
	}
}
#endif

void synthesis_subband_filter(const float xr[32 * 18], struct pcm_stream* const pcm_out, int ch, int nch)
{
	int i, j;
	unsigned step = nch << 1;
	float s[32], sum;

	for (int ss = 0; ss < 18; ++ss) {
		// Shifting
		_V_index[ch] = (_V_index[ch] - 64) & 0x3ff;

		for (i = 0; i < 32; ++i)
			s[i] = xr[i * 18 + ss];

		// Matrixing (DCT(32 -> 64))
		for (i = 0; i < 64; ++i) {
			sum = 0.0f;
			for (j = 0; j < 32; ++j) {
				sum += _N[i][j] * s[j];
			}
			_V[ch][_V_index[ch] + i] = sum;
		}

		// Build a 512 values vector U
		for (i = 0; i < 8 * 64; i += 64) {
			for (j = 0; j < 32; ++j) {
				_U[i + j] = _V[ch][i * 2 + j];
				_U[i + j + 32] = _V[ch][i * 2 + j + 96];
			}
		}

		// Window by 512 coefficients
		for (i = 0; i < 512; ++i) {
			_U[i] *= _D[i];
		}

		// Calculate 32 Samples
		for (i = 0; i < 32; ++i) {
			sum = 0.0f;
			for (j = 0; j < 16 * 32; j += 32) {
				sum += _U[i + j];
			}
			// Output 32 reconstructed PCM Samples
			int pcm_i = sum * 32767.0f;
			if (pcm_i > 32767)
				pcm_i = 32767;
			else if (pcm_i < -32767) {
				pcm_i = -32767;
			}
			pcm_i &= 0xffff;

			pcm_out->pcm_buf[pcm_out->write_off[ch]] = pcm_i & 0xff;
			pcm_out->pcm_buf[pcm_out->write_off[ch] + 1] = (pcm_i >> 8) & 0xff;
			pcm_out->write_off[ch] += step;
		}
	}
}
